import os, time, uuid, logging
from urllib.parse import urlparse
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import httpx

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("link-seguro")

APP_NAME = "link-seguro"
APP_VER  = "1.0.0"

OTX_API_KEY = os.getenv("OTX_API_KEY","").strip()

# --- FastAPI + CORS ---
app = FastAPI(title=APP_NAME, version=APP_VER)

origins = [o.strip() for o in os.getenv("ALLOWED_ORIGINS","").split(",") if o.strip()]
if not origins:
    origins = ["http://127.0.0.1:5500", "http://localhost:5500"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class LinkIn(BaseModel):
    url: str

@app.get("/healthz")
async def healthz():
    return {"status":"ok","app":APP_NAME,"version":APP_VER}

def simple_heuristics(u: str) -> str:
    u_low = u.lower()
    bad_terms = ["pix","boleto","login","secure","verificar","verify","senha","password","cartao","bank","banco"]
    score = 0
    for t in bad_terms:
        if t in u_low:
            score += 1
    if u_low.startswith("http://"):
        score += 1
    if score >= 3:
        return "dangerous"
    if score >= 1:
        return "suspicious"
    return "unknown"

async def safe_check(url: str) -> dict:
    try:
        p = urlparse(url)
        if p.scheme not in ("http","https") or not p.hostname:
            return {"ok": False, "status": None, "reason": "bad_scheme_or_host"}
        async with httpx.AsyncClient(timeout=3.5, follow_redirects=True) as client:
            r = await client.get(url, headers={"User-Agent":"LinkSeguro/1.0"})
            return {"ok": (200 <= r.status_code < 400), "status": r.status_code}
    except Exception as e:
        return {"ok": False, "status": None, "error": str(e)[:160]}

async def check_otx(url: str) -> dict:
    p = urlparse(url)
    host = p.hostname or ""
    headers = {}
    if OTX_API_KEY:
        headers["X-OTX-API-KEY"] = OTX_API_KEY
    out = {"used": False, "decision": "unknown", "domain_pulses": 0}
    if not host:
        return out
    try:
        async with httpx.AsyncClient(timeout=4.0) as client:
            r = await client.get(f"https://otx.alienvault.com/api/v1/indicators/domain/{host}/general", headers=headers)
            if r.status_code == 200:
                js = r.json()
                pulses = int(js.get("pulse_info",{}).get("count", 0))
                out["domain_pulses"] = pulses
                out["used"] = True
                if pulses >= 1:
                    out["decision"] = "dangerous"
            if out["decision"] != "dangerous":
                from base64 import urlsafe_b64encode
                enc = urlsafe_b64encode(url.encode()).decode().rstrip("=")
                r2 = await client.get(f"https://otx.alienvault.com/api/v1/indicators/url/{enc}/general", headers=headers)
                if r2.status_code == 200:
                    js2 = r2.json()
                    pulses2 = int(js2.get("pulse_info",{}).get("count", 0))
                    out["url_pulses"] = pulses2
                    out["used"] = True
                    if pulses2 >= 1:
                        out["decision"] = "dangerous"
    except Exception as e:
        out["error"] = str(e)[:160]
    return out

@app.post("/validar_link")
async def validar_link(inp: LinkIn):
    t0 = time.time()
    trace = str(uuid.uuid4())
    url = inp.url.strip()
    extra = {}

    decision = simple_heuristics(url)
    source = "heuristics"

    sc = await safe_check(url)
    extra["safe_check"] = sc

    otx_res = await check_otx(url)
    if otx_res.get("used"):
        extra["otx"] = {k:v for k,v in otx_res.items() if k not in ("used",)}
        if otx_res.get("decision") == "dangerous":
            decision = "dangerous"
            source = "otx"
        elif decision == "unknown":
            source = "heuristics+otx"

    took = int((time.time()-t0)*1000)
    log.info('{"ts":"%s","level":"INFO","msg":"request","trace_id":"%s","decision":"%s"}',
             time.strftime("%Y-%m-%dT%H:%M:%S"), trace, decision)
    return {
        "status":"success",
        "decision": decision,
        "trace_id": trace,
        "source": source,
        "url": url,
        "vt_summary": None,
        "error": None,
        "took_ms": took,
        "http_status": 200,
        "sent_trace": trace,
        "extra": extra,
    }
